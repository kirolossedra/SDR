import socket
import time
import threading
from collections import deque
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox

# Configuration
PORT = 5005
PACKET_SIZE = 1024         # Changed to 1024 as requested
IDLE_TIMEOUT = 1.0         # Seconds of silence â†’ burst ends

def receiver_function(stop_event, statistics, lock, log_callback):
    # Set up UDP socket for broadcast
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 0)
    except Exception:
        pass
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 256 * 1024)
    sock.bind(("", PORT))
    sock.settimeout(0.5)  # Shorter timeout for more responsive stopping

    burst_count = 0
    burst_start = None
    burst_last = None
    thread_name = threading.current_thread().name

    log_callback(f"{thread_name}: Listening for broadcasts on port {PORT}...")

    while not stop_event.is_set():
        try:
            data, addr = sock.recvfrom(PACKET_SIZE)
            now = time.time()
            log_callback(f"{thread_name}: Received packet from {addr}")
            if burst_count == 0:
                burst_start = now
            burst_last = now
            burst_count += 1
        except socket.timeout:
            if burst_count > 0:
                elapsed = burst_last - burst_start
                mb_recv = burst_count * PACKET_SIZE / (1024 * 1024)
                mbps = mb_recv * 8 / elapsed
                with lock:
                    statistics.append((thread_name, burst_start, burst_last, burst_count, mb_recv, mbps))
                log_callback(f"{thread_name}: Burst ended. Packets: {burst_count}, MiB: {mb_recv:.2f}, Mbps: {mbps:.2f}")
                burst_count = 0
                burst_start = None
                burst_last = None
            if stop_event.is_set():
                break
            log_callback(f"{thread_name}: Waiting for data...")
        except OSError as e:
            if getattr(e, 'winerror', None) == 10040:
                now = time.time()
                if burst_count == 0:
                    burst_start = now
                burst_last = now
                burst_count += 1
                log_callback(f"{thread_name}: Received oversized packet")
            else:
                raise
    sock.close()
    log_callback(f"{thread_name}: Stopped.")

class UDPReceiverGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("UDP Receiver Monitor")
        self.root.geometry("800x600")
        
        # Shared variables
        self.stop_event = None
        self.statistics = None
        self.lock = None
        self.threads = []
        self.is_running = False
        
        self.setup_ui()
        
    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configuration frame
        config_frame = ttk.LabelFrame(main_frame, text="Configuration", padding="10")
        config_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(config_frame, text="Number of threads:").grid(row=0, column=0, sticky=tk.W)
        self.thread_var = tk.StringVar(value="1")
        thread_spinbox = ttk.Spinbox(config_frame, from_=1, to=50, textvariable=self.thread_var, width=10)
        thread_spinbox.grid(row=0, column=1, sticky=tk.W, padx=(10, 0))
        
        ttk.Label(config_frame, text=f"Port: {PORT}").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(config_frame, text=f"Packet Size: {PACKET_SIZE} bytes").grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(5, 0))
        
        # Control frame
        control_frame = ttk.Frame(main_frame)
        control_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.start_button = ttk.Button(control_frame, text="Start Listening", command=self.start_listening)
        self.start_button.grid(row=0, column=0, padx=(0, 5))
        
        self.stop_button = ttk.Button(control_frame, text="Stop", command=self.stop_listening, state="disabled")
        self.stop_button.grid(row=0, column=1, padx=(5, 5))
        
        self.clear_button = ttk.Button(control_frame, text="Clear Log", command=self.clear_log)
        self.clear_button.grid(row=0, column=2, padx=(5, 0))
        
        # Status frame
        status_frame = ttk.Frame(main_frame)
        status_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.status_label = ttk.Label(status_frame, text="Status: Ready")
        self.status_label.grid(row=0, column=0, sticky=tk.W)
        
        # Log frame
        log_frame = ttk.LabelFrame(main_frame, text="Activity Log", padding="5")
        log_frame.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=15, width=70)
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Statistics frame
        stats_frame = ttk.LabelFrame(main_frame, text="Burst Statistics", padding="5")
        stats_frame.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(10, 0), pady=(0, 10))
        
        self.stats_text = scrolledtext.ScrolledText(stats_frame, height=15, width=50)
        self.stats_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(3, weight=1)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        stats_frame.columnconfigure(0, weight=1)
        stats_frame.rowconfigure(0, weight=1)
        
    def log_message(self, message):
        """Thread-safe logging to the GUI"""
        def update_log():
            self.log_text.insert(tk.END, f"{time.strftime('%H:%M:%S')} - {message}\n")
            self.log_text.see(tk.END)
        
        self.root.after(0, update_log)
        
    def update_statistics(self):
        """Update the statistics display"""
        if not self.statistics:
            return
            
        def update_stats():
            self.stats_text.delete(1.0, tk.END)
            
            if len(self.statistics) > 0:
                with self.lock:
                    stats_copy = list(self.statistics)
                
                header = "{:<10} {:<10} {:<10} {:<8} {:<8} {:<8}\n".format(
                    "Thread", "Start", "End", "Packets", "MiB", "Mbps"
                )
                self.stats_text.insert(tk.END, header)
                self.stats_text.insert(tk.END, "-" * 60 + "\n")
                
                total_mbps = 0
                for stat in sorted(stats_copy, key=lambda x: x[1]):
                    thread_name, burst_start, burst_last, burst_count, mb_recv, mbps = stat
                    start_str = time.strftime('%H:%M:%S', time.localtime(burst_start))
                    end_str = time.strftime('%H:%M:%S', time.localtime(burst_last))
                    line = "{:<10} {:<10} {:<10} {:<8} {:<8.2f} {:<8.2f}\n".format(
                        thread_name, start_str, end_str, burst_count, mb_recv, mbps
                    )
                    self.stats_text.insert(tk.END, line)
                    total_mbps += mbps
                
                # Add average throughput
                if len(stats_copy) > 0:
                    avg_mbps = total_mbps / len(stats_copy)
                    self.stats_text.insert(tk.END, "-" * 60 + "\n")
                    self.stats_text.insert(tk.END, f"Average Throughput: {avg_mbps:.2f} Mbps\n")
        
        self.root.after(0, update_stats)
        
    def start_listening(self):
        try:
            num_threads = int(self.thread_var.get())
            if num_threads <= 0:
                messagebox.showerror("Error", "Number of threads must be positive")
                return
        except ValueError:
            messagebox.showerror("Error", "Invalid number of threads")
            return
            
        # Initialize shared variables
        self.stop_event = threading.Event()
        self.statistics = deque()
        self.lock = threading.Lock()
        self.threads = []
        
        # Create and start threads
        for i in range(num_threads):
            thread = threading.Thread(
                target=receiver_function,
                args=(self.stop_event, self.statistics, self.lock, self.log_message),
                name=f"Thread-{i+1}"
            )
            self.threads.append(thread)
            thread.start()
            
        self.is_running = True
        self.start_button.config(state="disabled")
        self.stop_button.config(state="normal")
        self.status_label.config(text=f"Status: Listening with {num_threads} threads")
        
        self.log_message(f"Started listening on port {PORT} with {num_threads} threads")
        
        # Start periodic statistics update
        self.update_stats_periodic()
        
    def stop_listening(self):
        if self.is_running and self.stop_event:
            self.log_message("Stopping threads...")
            self.stop_event.set()
            
            # Give threads time to see the stop event and exit gracefully
            for thread in self.threads:
                thread.join(timeout=2.0)  # Wait max 2 seconds per thread
                if thread.is_alive():
                    self.log_message(f"Warning: {thread.name} did not stop gracefully")
                
            self.is_running = False
            self.start_button.config(state="normal")
            self.stop_button.config(state="disabled")
            self.status_label.config(text="Status: Stopped")
            
            self.log_message("All threads stopped")
            self.update_statistics()  # Final update
            
    def clear_log(self):
        self.log_text.delete(1.0, tk.END)
        
    def update_stats_periodic(self):
        """Periodically update statistics while running"""
        if self.is_running:
            self.update_statistics()
            self.root.after(1000, self.update_stats_periodic)  # Update every second
            
    def on_closing(self):
        if self.is_running:
            self.stop_listening()
        self.root.destroy()

def main():
    root = tk.Tk()
    app = UDPReceiverGUI(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()
